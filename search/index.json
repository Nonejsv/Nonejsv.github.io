[{"content":"","date":"2025-12-11T16:16:24+08:00","permalink":"http://localhost:1313/p/%E6%B5%8B%E8%AF%95/","title":"测试"},{"content":"Springboot配置文件 在前文我们一直使用的是Springboot项目创建之后自带的application.properties进行属性的配置，但是一旦在大型项目之中采用properties配置文件这种键值对key=value的形式，就会显得结构不清晰，比较臃肿\n1.配置文件格式 Springboot项目提供了多种属性配置的方式（properties、yaml、yml） yml格式配置文件名字为：application.yaml , application.yml 这两个配置文件的后缀名虽然不一样，但是里面配置的内容形式都是一模一样的。\n而是用yml格式来进行配置信息，更加简洁、明了、以数据为中心\n对比图如上\n2. 语法 在了解了不同配置文件之间的优缺点之后，接下来我们就来了解配置文件的基本语法：\n大小写敏感 数值前面必须有空格，作为分隔符号 使用缩进表示层级关系，缩进时，不允许使用tab键，只能用空格（idea会自动把tab键转化为空格） 缩进的空格数目不重要，只要做到相同层级的元素左侧对齐就行 #表示注释，从这个字符开始一直到行尾，都会被解析器省略 了解了yml格式配置文件的基本语法之后，我们再来看看yml文件之中的常见的数据格式。在这里我们介绍最为常见的两类：\n定义对象或Map集合 定义数组、list或者set集合 对象/Map集合 1 2 3 4 user: name: zhangsan age: 18 password: 123456 数组/List/Set集合 1 2 3 4 hobby: - java - game - sport 3. 案例 配置文件的内容如下：\n1 2 3 4 5 6 7 8 9 10 11 #数据源配置 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/web01 username: root password: root@1234 #mybatis配置 mybatis: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl ","date":"2025-12-06T12:45:20+08:00","permalink":"http://localhost:1313/p/spring-boot/","title":"Spring boot"},{"content":"","date":"2025-12-06T11:26:16+08:00","permalink":"http://localhost:1313/p/jvm/","title":"JVM"},{"content":"并发编程 1.概览 加下来记录的笔记中所谓的【并发】涵盖了\n进程 线程 并发 并行 以及java开发工具、并发问题以及解决方案，同时一些其他领域的并发。\n2.进程和线程 进程\n","date":"2025-12-06T11:26:03+08:00","permalink":"http://localhost:1313/p/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","title":"并发编程"},{"content":"方法引用 ","date":"2025-12-05T23:02:29+08:00","permalink":"http://localhost:1313/p/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","title":"方法引用"},{"content":"","date":"2025-12-05T22:59:52+08:00","permalink":"http://localhost:1313/p/file/","title":"File"},{"content":"单元测试 1.引言 测试：是一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。 阶段划分：单元测试、集成测试、系统测试、验收测试。 而我们今天要学习的就是单元测试。\n测试方法：黑盒测试、白盒测试和灰盒测试。 课程安排如上。\n2. 单元测试 介绍：所谓单元测试，就是说针对最小的功能单元（方法），编写测试代码对其正确性进行测试。\n注意注意，在框架文件夹之中的test文件夹就是专门存放单元测试的代码的，不会影响源代码，但又方便我们进行测试。\nJUnit：是现在最流行的Java测试框架之一，提供了一些功能，方便程序进行单元测试。 有的哥们就要问了:apple U,为什么测试代码不能直接在main方法里面自己调用来进行测试嘛？\n问得好，我来助你！\nrt，main方法的测试有着许多问题，无法自动进行测试，需要手动调试，十分麻烦\n但是如果使用了JUnit进行对方法的测试，十分便利\n3.JUnit入门程序 注意：\n测试类的命名规范为：XxxxTest 测试方法的命名规定（必须这样）为：public void xxx(){\u0026hellip;} 示例代码：\n局部总结：\nJUnit单元测试是干什么 JUnit单元测试的优点是什么 他的命名规范 4.断言 思考：如果单元测试运行不报错（绿色），就一定能说明我们的方法没有问题吗，这只能说明我们在写的单元测试下没有问题（突然理解了，必须有断言，要不然单纯的单元测试无法做出正确的判断，此处的绿色只是说明我们编写的单元测试代码可以正常运行），却不能说明原始的业务方法的逻辑没有问题\n这个时候就要用到了断言，他是一个JUnit提供的一些辅助方法，可以帮助我们确定被测试的方法是否能够按照预定的效果正常工作，\n使用的时候大概要这个样子\n写在单元测试代码里面\n5. 常见注解 （） 前文我们在进行代码示范的时候，有见到过@Test注解，这是JUnit中十分重要的注解，\n如下图，还有其他许多比较常见的注解\n@Test @ParameterizedTest @DisplayName @BeforEach @AfterEach @BeforeAll @AfterAll @ParameterizedTest和@DisplayName一般会搭配使用\n可以自动运行多次测试多个参数\n感觉单元测试有趣的点在于可以自由调节代码的执行顺序（通过断言）\n比如这样\n还可以用这样的来进行命名，在输出平台也方便辨认\n1.JUnit单元测试的方法，是否可以声明方法形参\n2.如何实现在单元测试方法运行之前，做一些初始化操作\n3.如何实现在单元测试方法运行之后，释放对应的资源\n6.单元测试的企业开发规范 + AI生成单元测试代码 6.1 企业开发规范 原则：编写测试方法时，要尽可能的覆盖业务方法中所有可能得情况（尤其是边界值，就是说特殊情况） 在运行单元测试时可以选择第三项使用覆盖率运行可以统计你是否每种类每个方法每个分支都进行了针对性的测试，可方便查看自己单元测试编写的覆盖率，但是也不一定就能包括一些特殊情况。\n7.Maven依赖范围 在Maven项目中，test目录存放单元测试的代码，是否可以在main目录里面编写单元测试呢？\n回答：可以是可以，但是不规范，我们也可以自己通过Maven的依赖范围限制让我们无法再main文件夹里面书写单元测试\n依赖的jar包，默认情况下，可以再任何地方使用。可以通过\u0026lt;scope\u0026gt;\u0026lt;/scope\u0026gt;设置作用范围 作用范围： 主程序范围有效（main文件夹范围内） 测试程序范围内有效（test文件夹范围内） 是否参与打包运行（package指令范围内） 可以在scope标签里面写入\n使用test的scope值的最常见的场景就是JUnit了\n小结：\nMaven的依赖范围如何制定 常见的取值有哪些？ 8. 附加：Maven的生命周期 在运行生命周期中的test阶段时，只会运行命名规范的单元测试，如果不规范就不会运行，所以要尽量规范啊，而且正常运行的数量会在输出语句中可以查询\n而这个红色框框里面的按钮可以选择是否跳过test阶段，因为在运行下面的生命周期的时候，会自动先运行上面的生命周期\n","date":"2025-12-05T18:35:55+08:00","permalink":"http://localhost:1313/p/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","title":"单元测试"},{"content":"类加载器 1.类加载器 作用：\n​\t负责把.class文件（存储在硬盘之中的物理文件）加载在内存之中\n1.2 类加载器的完整过程 类加载时机\n简单理解：字节码文件为什么会被加载到内存中\n疑惑：字节码文件属于什么\n加载： 验证： 准备： 解析： 初始化 ","date":"2025-12-05T11:01:28+08:00","permalink":"http://localhost:1313/p/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","title":"类加载器"},{"content":"类加载器 1.类加载器 作用：\n​\t负责把.class文件（存储在硬盘之中的物理文件）加载在内存之中\n1.2 类加载器的完整过程 类加载时机\n简单理解：字节码文件为什么会被加载到内存中\n疑惑：字节码文件属于什么\n加载： 验证： 准备： 解析： 初始化 ","date":"2025-12-05T11:01:28+08:00","permalink":"http://localhost:1313/p/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","title":"类加载器"},{"content":"反射\u0026amp;动态代理 1.反射 1.1反射的概述 可以获取的东西包括类里面的全部信息，但是反射不是直接从java文件中获取的类的信息，而是通过编译之后的class字节码文件进行获取，所以我们要先学习如何获取字节码文件的对象，再去学习如何从字节码文件中获取到字段（成员变量）等等。\n反射允许对成员变量，成员方法和构造方法的信息进行编程访问。\n（思考题目）为什么不用IO流来进行编程访问呢？\n答：如果用IO流进行读取则无法正确进行一些基础判断，比如是成员变量还是局部变量，虽然同样可以实现，但是显然使用反射更加便捷\n1.2 获取class对象的三种方式 三种方式分别与三个阶段对应\n","date":"2025-12-05T10:49:00+08:00","permalink":"http://localhost:1313/p/%E5%8F%8D%E5%B0%84/","title":"反射"},{"content":"反射\u0026amp;动态代理 1.反射 1.1反射的概述 可以获取的东西包括类里面的全部信息，但是反射不是直接从java文件中获取的类的信息，而是通过编译之后的class字节码文件进行获取，所以我们要先学习如何获取字节码文件的对象，再去学习如何从字节码文件中获取到字段（成员变量）等等。\n反射允许对成员变量，成员方法和构造方法的信息进行编程访问。\n（思考题目）为什么不用IO流来进行编程访问呢？\n答：如果用IO流进行读取则无法正确进行一些基础判断，比如是成员变量还是局部变量，虽然同样可以实现，但是显然使用反射更加便捷\n1.2 获取class对象的三种方式 三种方式分别与三个阶段对应\n","date":"2025-12-05T10:49:00+08:00","permalink":"http://localhost:1313/p/%E5%8F%8D%E5%B0%84/","title":"反射"},{"content":"集合 1.Collection集合 1.1 数组和集合的区别： ","date":"2025-12-04T20:58:33+08:00","permalink":"http://localhost:1313/p/%E9%9B%86%E5%90%8801/","title":"集合01"},{"content":"前言 在进行后端程序的开发时，我们通常会使用java程序来进行对数据库的操作，比如最底层的JDBC\n课程安排：\nJDBC Mybatis Springboot配置文件 1.JDBC 1.1 介绍 JDBC：（Java DataBase Connectivity），就是使用Java语言操作关系型数据库的一套API。\n","date":"2025-12-04T15:38:41+08:00","permalink":"http://localhost:1313/p/java%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"Java操作数据库"},{"content":"MySQl操作库 ","date":"2025-12-04T15:34:40+08:00","permalink":"http://localhost:1313/p/mysql%E5%9F%BA%E7%A1%80/","title":"MySQL基础"},{"content":"总览 内容：\nspringBoot入门 http协议 springboot案例 分层解耦 静态资源：指的是存储在服务器上面不会改变的数据，不会根据用户的请求而改编\n动态资源：内容可能在每次额度请求时发生变化，动态生成的\n对于java程序开发的动态资源来说，我们通常会部署在Tomcat这样的服务器上运行，而浏览器与服务器通信的时候，基本都是基于http协议的。\n俗称BS架构\n与之对应的是CS架构。\n1. springBoot入门 介绍 在spring家族中最基础核心的技术就是springframework，可以提供很多实用的功能，比如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。\n但是由于直接使用springframework比较繁琐复杂，我们可以先通过另一个项目springboot来帮助我们快速构建应用程序。\n对比：\nspringframework springboot 配置繁琐、入门难度大 简化配置、快速开发 Spring Boot 可以帮助我们非常快速的构建应用程序、简化开发、提高效率 。\n而直接基于SpringBoot进行项目构建和开发，不仅是Spring官方推荐的方式，也是现在企业开发的主流。\n入门程序 常见问题：\n网络连接问题\n​\t使用阿里云提供的脚手架，网址为：https://start.aliyun.com\n入门解析 为什么springboot项目里面一个main方法就可以启动web应用？\n因为我们在创建springboot项目的时候，选择了web开发的起步依赖 spring-boot-starter-web。而spring-boot-starter-web依赖，又依赖了spring-boot-starter-tomcat，由于maven的依赖传递特性，那么在我们创建的springboot项目中也就已经有了tomcat的依赖，这个其实就是springboot中内嵌的tomcat。\n在我们运行main方法的时候，启动的就是springboot内嵌的Tomcat服务器，我们开发的项目会自动部署在tomcat服务器里面，默认占用8080端口号。\n😗起步依赖：\n一种为开发者提供简化配置和集成的机制，就是让开发者可以更加轻松地构建spring应用程序。 2. http协议 概述 hyper text transfer protocol（超文本传输协议），规定了浏览器与服务器之前传输数据的规则。\n浏览器向服务器发出请求：\n服务器向浏览器发出响应：\n两者都要按照固定格式解析\n今天我们学习的http协议，就是来学习请求和响应数据的具体格式内容。\n特点 基于TCP协议：安全，面向连接 **TCP是一种面向连接的（建立连接之前需要经过三次握手）、可靠的、基于字节流的传输层通信协议、在数据传输方面更加安全 （啥是tcp，啥事udp😵）\n基于请求-响应模型：一次请求对应一次响应（先请求后响应） 没有请求就没有响应，一一对应\nhttp协议是无状态协议，每次的请求-响应都是独立的，没有记忆能力 优点：速度快 缺点：多次请求之间无法共享数据（比如添加商品到购物车，不进行处理会默认没有记录添加购物车的是什么商品） 但是java已经提出了使用**会话技术（Cookie，Session）**来进行解决(wa,好开心，又能学到新的知识了，以后会提到) http请求协议 介绍： 请求协议：\n浏览器将数据以请求格式发送到服务器。\n包括：请求行，请求头，请求体\nget方式的请求协议 格式：\n请求行 * 请求头 post方式的请求协议 两者的区别： 区别方式 get请求 post请求 请求参数 请求参数在请求行中 清切参数在请求体中 请求参数长度 长度有限制 长度没有限制 安全性 安全性低，请求参数暴露在浏览器地址栏中 安全性相对高 获取请求数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @RestController public class RequestController { /** * 请求路径 http://localhost:8080/request?name=Tom\u0026amp;age=18 * @param request * @return */ @RequestMapping(\u0026#34;/request\u0026#34;) public String request(HttpServletRequest request){ //1.获取请求参数 name, age String name = request.getParameter(\u0026#34;name\u0026#34;); String age = request.getParameter(\u0026#34;age\u0026#34;); System.out.println(\u0026#34;name = \u0026#34; + name + \u0026#34;, age = \u0026#34; + age); //2.获取请求路径 String uri = request.getRequestURI(); String url = request.getRequestURL().toString(); System.out.println(\u0026#34;uri = \u0026#34; + uri); System.out.println(\u0026#34;url = \u0026#34; + url); //3.获取请求方式 String method = request.getMethod(); System.out.println(\u0026#34;method = \u0026#34; + method); //4.获取请求头 String header = request.getHeader(\u0026#34;User-Agent\u0026#34;); System.out.println(\u0026#34;header = \u0026#34; + header); return \u0026#34;request success\u0026#34;; } } http响应协议 格式介绍： 响应协议：服务器把数据以响应格式返回到浏览器。包括：响应行、响应头、响应体 响应行 响应头 响应体 响应状态码 设置响应数据 3. springboot案例 注意：\n业务开发中，不使用基础数据类型，使用的都是包装类，因为基础数据类型都带有默认的数值比如0，不便于我们分辨是他就是0还是默认值是0\n@Data @NoArgsConstructor（无参构造） @AllArgsConstructor（全参数构造）这三个是Lombok依赖里面的注解，可以帮助我们自动配置所有成员变量的get和set方法，具体用法会在下面说明哦\njava文件定义的成员变量要与html文件中的信息对应，否则会报错\nController专门存放请求处理类（叫做控制层嘛），\n@RestController这个注解是用来干嘛的？\n4. 分层解耦 4.1 三层架构 4.1.1 介绍 在我们进行程序设计以及程序开发时，尽可能让每一个接口、类、方法的职责更加单一（单一职责原则）\n单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。\n这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利于后期的维护。\n之前设计的案例程序，不满足单一职责原则。\n上述案例的处理逻辑，可以分成三部分：\n数据访问：负责业务数据的维护操作，包括增、删、改、查等操作。 对应Dao层 逻辑处理：负责业务逻辑处理的代码。 对应Service层 请求处理、响应数据：负责，接收页面的请求，给页面响应数据。 对应Controller层 于是，我们在项目开发之中，可以把代码分成三层，如图所示：\nController：控制层。接收前端发送的请求，对请求进行处理，并响应数据。 Service：业务逻辑层。处理具体的业务逻辑。 Dao:数据访问层（Data Access Object），也称为持久层。负责数据访问操作，包括数据的增删改查。 前端发起的请求，由Controller层接收（Controller响应数据给前端）\nController层调用Service层来进行逻辑处理（Service层处理完后，把处理结果返回给Controller层）\nSerivce层调用Dao层（逻辑处理过程中需要用到的一些数据要从Dao层获取）\nDao层操作文件中的数据（Dao拿到的数据会返回给Service层）\n如果对业务逻辑层进行修改，不会影响其他两层，提高了程序的扩展性和可维护性。\n4.1. 2 代码实现 4.2 分层解耦 4.3 IOC\u0026amp;DI入门 如果我们想要实现解耦操作，就涉及到了Spring的两个核心概念：\n控制反转：Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器）😵\n（byd我怎么看不懂这句话什么意思？）\n依赖注入：Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。\nbean对象：IOC容器中创建、管理的对象，称之为：bean对象。\n4.4 IOC详解 4.5 DI详解 ","date":"2025-12-03T09:51:13+08:00","permalink":"http://localhost:1313/p/%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80/","title":"后端基础"},{"content":"Maven ","date":"2025-12-02T22:53:16+08:00","permalink":"http://localhost:1313/p/maven/","title":"Maven"},{"content":"正则表达式 1. 概述 正则表达式的作用 正则表达式的字符类 正则表达式的逻辑运算符 正则表达式的预定义字符类 正则表达式的限定符 正则表达式的分组 在String的split方法中使用正则表达式 2. 概念 正则表达式可以用于验证字符串是否符合规范，就是用来验证各种字符串的规则，内部描述了一些规则，可以验证用户输入的字符串是否符合这个规则。\n可以校验字符串是否满足规则 在一串文本中查找需要的内容 字符串的自带方法matches\n3. 字符类 示例：\n\\[abc\\]：代表a或者b，或者c字符中的一个。 \\[^abc\\]：代表除a,b,c以外的任何字符。 [a-z]：代表a-z的所有小写字符中的一个。 [A-Z]：代表A-Z的所有大写字符中的一个。 [0-9]：代表0-9之间的某一个数字字符。 [a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。 [a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。 字符类一个中括号只能对应一个字符，多个字符出现则会返回false，说明字符的个数也需要严格匹配。\n\u0026amp;\u0026amp;如下的逻辑运算符，可以用在表示不同的范围上面\n4. 逻辑运算符 \u0026amp;\u0026amp;：并且 | ：或者 \\ ：转义字符 5. 预定义字符 \u0026quot; . \u0026quot; ： 匹配任何字符。 \u0026ldquo;\\d\u0026rdquo;：任何数字[0-9]的简写； \u0026ldquo;\\D\u0026rdquo;：任何非数字\\[^0-9\\]的简写； \u0026ldquo;\\s\u0026rdquo;： 空白字符：[ \\t\\n\\x0B\\f\\r] 的简写 \u0026ldquo;\\S\u0026rdquo;： 非空白字符：\\[^\\s\\] 的简写 \u0026ldquo;\\w\u0026rdquo;：单词字符：[a-zA-Z_0-9]的简写 \u0026ldquo;\\W\u0026rdquo;：非单词字符：\\[^\\w\\] 拓展：转义字符\\\n因为一个杠是表示转移字符，这是他原本的含义，当我们想要杠来表示出其他的含义时，就需要再来一个杠来转义第二个杠。\n小写的与大写的是相反的，而预定义字符是对常用字符类的快捷概括\n6. 数量词 因为前面学习的字符类和预定义字符都是针对一个字符来进行匹配，需要数量词来进行对数量的约束。\nX 是用来表示任意内容的。（可以用字符类或者预定义字符来代表）\n注意：不需要死记硬背每个符号表示什么，上面涉及的只是正则表达式的一部分，有个大概的了解，要用到的时候直接去查找API文档就可以。\n7.爬虫 8.String 9.分组括号（） 10.非捕获分组 概念：\n分组之后不需要再用本组数据，而仅仅是把数据括起来。\n","date":"2025-11-29T19:12:00Z","permalink":"http://localhost:1313/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"正则表达式"},{"content":"抽象类 1. 概述 针对面向对象中的继承专门设置\n使用了关键词abstract来进行对方法的定义，这样的方法可以叫做抽象类，抽象方法所在的类就叫做抽象类。\n可以用来解决在应对继承某些人故意不去重写子类的方法来应对需求，如果用abstract来进行标记，则在创造子类时必须进行对方法的重写，要不然报错。\n2.抽象方法 抽象方法：将共性的行为（方法）抽取到父类之后，由于每一个子类的执行内容不一样，所以在父类之中不能确认具体的方法体。这样的方法就叫做抽象方法。 抽象类:如果一个类之中存在抽象方法，该类就必须声明为抽象类。 定义格式：\n抽象方法：public abstract 返回值类型 方法名（参数列表）；\n​\t（注意：抽象方法没有方法体，直接写分号结束）\n抽象类：public abstract class 类名{}\n注意事项：\n抽象类不能实例化（抽象类不可以创建对象） 抽象类不一定有抽象方法，有抽象方法一定是抽象类 可以有构造方法（可是他都不可以创建对象，要构造方法干什么？抽象类的子类有什么用） 抽象类的子类 要么重写父类中的所有抽象方法 要么子类也是抽象类 接口 1. 为什么有接口？ 在面向对象的过程中，会遇到比如一个父类多个子类的情况下，想要给几个特定的子类中接入同一个方法，但是也要限定某几个子类不会接入同一个方法，这种情况下不能直接把这个方法写在父类之中，否则这个方法会所有的子类都具有，不符合我们的要求。\n这个时候，就需要接口的存在，我们可以设定单一方法的接口，然后再我们需要的子类中接入这个接口，就可以实现相应的方法，符合我们的需求了。\n注意，接口之中全部都是抽象方法，接口之中同样也是不可以创建对象的\n2. 定义格式 1 2 3 4 5 6 7 //接口的定义格式： interface 接口名称{ // 抽象方法 } // 接口的声明：interface // 接口名称：首字母大写，满足“驼峰模式” 接口的声明：interface\n3. 接口的特点 在JDK7，接口中只有包含：抽象方法和常量\n3.1 抽象方法 注意，接口之中的抽象方法会自动加上public abstract修饰，而我们不需要自己手动再加上。\n按照规范，这个不用加，因为默认会加上\n3.2 常量 在接口之中的成员变量会自动加上public abstract final来进行修饰，所以说他实际上不可被修改，是一个常量。同时静态化的变量可以直接用接口名访问，所以也叫作常量。\n常量必须要给初始值，同时建议命名全部用大写字母，多个单词用下划线连接。\n4. 基本的实现 （😘家人们，终于看到实现了）\n4.1 概述 类和接口之间的关系叫做实现关系，即类实现接口，这个类可以叫做接口的实现类，也可以叫做接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用implements关键字。\n4.2 实现格式 5. 接口和接口的多继承 类与接口是实现关系 接口与接口是继承关系 接口继承接口就是把其他接口的抽象方法与本接口进行了合并。\n内部类 概述 类的五大成员：属性，方法，构造方法，代码块，内部类\n属性 方法 构造方法 代码块 内部类（双重类） 思考应用场景：\n类是一个抽象对象，而属性和行为是他的主体，但是属性也可以有多种分类，比如人可以分为器官组织细胞，从某个层面来说，器官这类也属于一个单独的个体，这个时候就可以使用内部类加以分类\nB类事物是A类事物的一部分，而且B类事物单独存在没有意义\n比如：汽车的发动机，ArrayList的迭代器，人的心脏\n内部类表示的事物是外部的一部分\n内部类单独出现没有意义\n内部类的访问特点：\n可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象（有点不理解：大概就是在外部类调用内部类是，要先用new的方式创建对象） 举例：Arraylist中的迭代器也是一种内部类\n使用快捷键ctrl+F2 可以快速查看当前类的内部结构（包含的方法，内部类等）\n内部类的分类 成员内部类 静态内部类 局部内部类 匿名内部类 （前三个了解即可，会在看源代码是去了解，第四个最重要）\n匿名内部类 （就是隐藏了名字的内部类，可以写在成员位置（方法外面），也可以写在局部位置（方法里面））\n书写格式：\n1 2 3 4 5 new 类名或者接口名（） { ​\t//重写方法； }； 实现关系（实现了类名或者接口名的关系） 方法的重写（） 创建对象（使用了new创建没有名字的对象） （从语法上来解释，应该叫做匿名内部类的对象）\n使用场景 当我们希望定义一个只会使用一次的类，就可以考虑使用匿名内部类。本质上，它可以简化代码。 之前所学习的内容在使用接口时，有如下操作（我是跳过来的，不知道有什么操作）：\n定义子类 重写接口中的方法 创建子类对象 调用重写后的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 interface Swim { public abstract void swimming(); } // 1. 定义接口的实现类 class Student implements Swim { // 2. 重写抽象方法 @Override public void swimming() { System.out.println(\u0026#34;狗刨式...\u0026#34;); } } public class Test { public static void main(String[] args) { // 3. 创建实现类对象 Student s = new Student(); // 4. 调用方法 s.swimming(); } } 而匿名内部类就是简化四步为一步的快捷方式\n匿名内部类的前提和格式 必须继承一个父类或者实现一个父接口\n格式：\n1 2 3 4 5 6 7 new 父类名或者接口名(){ // 方法重写 @Override public void method() { // 执行语句 } }; 匿名内部类的特点 ","date":"2025-11-26T11:18:00Z","permalink":"http://localhost:1313/p/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E5%86%85%E9%83%A8%E7%B1%BB/","title":"抽象类\u0026接口\u0026内部类"},{"content":"this关键字的作用 想起来了就近原则和就远原则区别，\nhey有没有弄明白呢现在\n明白了,this是就远原则\n🤗(●\u0026rsquo;◡\u0026rsquo;●)\n小疑惑 那种可以自动生成private的封装功能的成员方法的快捷键是什么?\n快捷键alt + insert可以自动插入什么东西？ 方法重载怎么用的？\n顶层父类是Object类。所有的类默认继承Object，作为父类，什么意思？\n捕获异常怎么用？\n啥是实现类构造器？\n多态体现的实现关系是什么意思？\nArrays.toString是什么东西？\n纳尼纳尼what is xml？\n方法的方法重载如果形参的名字不一样,但是数据类型一样会构成重载嘛?\nAPI帮助文档怎么用?\n字符串的存储原理?\n继承里面构造方法里面继承后的特点-构造方法说是子类默认有一个super（）是什么意思？\n父类子类继承重写方法要写@Overrride吗\n什么是引用数据类型，什么是基础数据类型（存储的是数据还是地址的意思）\nnative是什么意思\n定义接口中的实现类是什么意思\n12.4\n引导类，实现类，注解@是什么\n代理对象，实体类\n激动的心，之前疑惑的@test原来就在单元测试之中学习到的，哈哈哈哈\n测试Properties类中的store方法这里面的property是什么\n","date":"2025-11-26T10:40:00Z","permalink":"http://localhost:1313/p/%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95%E7%82%B9%E4%BD%8D/","title":"疑惑记录点位"},{"content":"1.类和对象 如何理解\n简单描述来说的话，类是抽象的对象，而对象则是具象的类。\n类是对象的数据类型。类是由属性和行为两个部分组成的\n属性：在类中通过成员变量来体现 成员变量是什么（类之中方法之外的变量就是成员变量） 行为：在类中通过成员方法来体现 成员方法是什么：（相比于常见的方法要去掉static关键词即可） 哈哈，那么static又是什么呢：此事在面向对象进阶之中亦有记载，这里简单说明一下有无static修饰的区别在于是否独独属于这个对象还是整个类，会在进阶内仔细研究，Cialiao~ 属性是事物的特征，以学生为例子，性别年龄身高体重\n行为是事物能执行的操作，重点在于事物自身，比如人开门则是门的行为。\n1 2 3 4 5 6 7 8 9 public class 类名 { // 成员变量 变量1的数据类型 变量1； 变量2的数据类型 变量2; … // 成员方法 方法1; 方法2;\t} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 手机类： 类名： 手机(Phone) 成员变量： 品牌(brand) 价格(price) 成员方法： 打电话(call) 发短信(sendMessage) */ public class Phone { //成员变量 String brand; int price; //成员方法 public void call() { System.out.println(\u0026#34;打电话\u0026#34;); } public void sendMessage() { System.out.println(\u0026#34;发短信\u0026#34;); } } 2.对象如何使用 创建格式：\n类名 对象名 = new 类名（）； 调用成员的格式：\n对象名.成员变量 对象名.成员方法（）； 3.对象内存图 3.1 单个 此处内存相关的东西还有许多疑惑\n什么是栈内存\n什么是堆内存\n什么是方法区\n3.2 多个 4.成员变量和局部变量的区别 5.封装 封装的意思就是对象代表什么，就得封装对应的数据，并且提供数据对应的行为（）\n代码的实现：将类的信息隐藏，使得外部程序无法直接访问，但是可以通过事先定义好的方法来实现对应隐藏信息的操作和访问\nprivate关键字 它是一个修饰符，可以用来修饰成员（包括成员变量和成员方法）\n被private修饰的成员，只能在本类之中继续访问，而这样的成员变量如果需要被其他类使用，可以用事先定义好的方法进行访问 提供get变量名（），获取成员变量的值，方法用public修饰 提供set变量名（参数），来设置值，注意对应的方法要用public修饰 那么，与private对应的修饰符还有哪些呢baby\n修饰符 作用 大小 private public 小问题（static与这几个属于同一个类型嘛！！）\nthis关键字 this修饰的变量用于指代成员变量，主要作用可以解决局部变量和成员变量的重名，this是就远原则，指代的是在往外一层的成员变量，而不是当前成员方法的形参\n构造方法 概述\n构造方法是一种特殊的方法\n作用：创建对象\n格式：\n​\tpublic class 类名 {\n​\t修饰符 类名（参数）{\n​\t}\n​\t}\n功能：可以完成对象数据的初始化\n注意事项\n​\t主要默认用于生成对象的时候可以加上在括号里面加入参数进行数值的初始化\n1 Student s2 = new Student(\u0026#34;林青霞\u0026#34;); 而如果不专门自定义带参数的构造方法,则会默认使用无参的构造方法,可是一旦自定义了,再想使用无参的构造方法,就要专门定义一个无参的构造方法\n8.包 什么是包？ 说包你不认识，说package你总认识吧。\n包就是文件夹，用来管理不同功能的java类。\n（根据功能不同来进行分类）\n包名命名的规则：\n公司域名反写+包的作用，需要全部英文小写，见名知意\n什么是全类名\n包名+类名\n什么时候需要导包\n使用同一个包中的类时，不需要导包 使用java.lang包中的类时，不需要导包 其他情况都需要导包 9.权限修饰符 哈哈哈，终于到了这里，虽然我是跳着写过来凑数的，但这都不重要。\n所谓的权限修饰符在一开始接触java就能够看到，也就是所谓的public\n，同时呢与之对应的还有private，protected，默认啥也不写。\nprivate（私房钱） \u0026lt; 默认（家里的钱） \u0026lt; protected（给私生子的钱） \u0026lt; public（所有地方都可以）(作用范围：从小到大)\npublic： 默认：本类以及本包之内可以访问（那么有bro要问了，什么是包，你且往上一节看啊bro） protected： private：私有的，只有当前类可以直接访问 10.static关键词 概述 什么是static？\njava中的成员（变量和方法）等是存在所属性的，可以通过static关键词来识别。\n被static修饰的成员是属于类的放在静态区中 没有static修饰的成员变量和方法则是属于对象的 定义格式和使用 static是静态的意思，可以修饰成员变量或者方法。\n有static修饰的成员变量属于类，可以称为类变量或者静态成员变量。可以直接用类名访问（）\n格式：类名.静态变量\n没有static修饰的成员变量属于每个对象，叫做实例变量。\n（实例成员变量属于每个对象，必须先定义各自类的对象之后才可以访问）\n格式：对象.实例成员变量\n方法同理\n小结 static修饰成员时，该成员称为静态变量或者静态方法。该类的每个对象共享同一个类的静态变量或者静态方法 ","date":"2025-11-25T23:26:00Z","permalink":"http://localhost:1313/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","title":"面向对象"},{"content":"1.类和对象 如何理解\n简单描述来说的话，类是抽象的对象，而对象则是具象的类。\n类是对象的数据类型。类是由属性和行为两个部分组成的\n属性：在类中通过成员变量来体现 成员变量是什么（类之中方法之外的变量就是成员变量） 行为：在类中通过成员方法来体现 成员方法是什么：（相比于常见的方法要去掉static关键词即可） 哈哈，那么static又是什么呢：此事在面向对象进阶之中亦有记载，这里简单说明一下有无static修饰的区别在于是否独独属于这个对象还是整个类，会在进阶内仔细研究，Cialiao~ 属性是事物的特征，以学生为例子，性别年龄身高体重\n行为是事物能执行的操作，重点在于事物自身，比如人开门则是门的行为。\n1 2 3 4 5 6 7 8 9 public class 类名 { // 成员变量 变量1的数据类型 变量1； 变量2的数据类型 变量2; … // 成员方法 方法1; 方法2;\t} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 手机类： 类名： 手机(Phone) 成员变量： 品牌(brand) 价格(price) 成员方法： 打电话(call) 发短信(sendMessage) */ public class Phone { //成员变量 String brand; int price; //成员方法 public void call() { System.out.println(\u0026#34;打电话\u0026#34;); } public void sendMessage() { System.out.println(\u0026#34;发短信\u0026#34;); } } 2.对象如何使用 创建格式：\n类名 对象名 = new 类名（）； 调用成员的格式：\n对象名.成员变量 对象名.成员方法（）； 3.对象内存图 3.1 单个 此处内存相关的东西还有许多疑惑\n什么是栈内存\n什么是堆内存\n什么是方法区\n3.2 多个 4.成员变量和局部变量的区别 5.封装 封装的意思就是对象代表什么，就得封装对应的数据，并且提供数据对应的行为（）\n代码的实现：将类的信息隐藏，使得外部程序无法直接访问，但是可以通过事先定义好的方法来实现对应隐藏信息的操作和访问\nprivate关键字 它是一个修饰符，可以用来修饰成员（包括成员变量和成员方法）\n被private修饰的成员，只能在本类之中继续访问，而这样的成员变量如果需要被其他类使用，可以用事先定义好的方法进行访问 提供get变量名（），获取成员变量的值，方法用public修饰 提供set变量名（参数），来设置值，注意对应的方法要用public修饰 那么，与private对应的修饰符还有哪些呢baby\n修饰符 作用 大小 private public 小问题（static与这几个属于同一个类型嘛！！）\nthis关键字 this修饰的变量用于指代成员变量，主要作用可以解决局部变量和成员变量的重名，this是就远原则，指代的是在往外一层的成员变量，而不是当前成员方法的形参\n构造方法 概述\n构造方法是一种特殊的方法\n作用：创建对象\n格式：\n​\tpublic class 类名 {\n​\t修饰符 类名（参数）{\n​\t}\n​\t}\n功能：可以完成对象数据的初始化\n注意事项\n​\t主要默认用于生成对象的时候可以加上在括号里面加入参数进行数值的初始化\n1 Student s2 = new Student(\u0026#34;林青霞\u0026#34;); 而如果不专门自定义带参数的构造方法,则会默认使用无参的构造方法,可是一旦自定义了,再想使用无参的构造方法,就要专门定义一个无参的构造方法\n构造器 标准javabean类 8.包 什么是包？ 说包你不认识，说package你总认识吧。\n包就是文件夹，用来管理不同功能的java类。\n（根据功能不同来进行分类）\n包名命名的规则：\n公司域名反写+包的作用，需要全部英文小写，见名知意\n什么是全类名\n包名+类名\n什么时候需要导包\n使用同一个包中的类时，不需要导包 使用java.lang包中的类时，不需要导包 其他情况都需要导包 9.权限修饰符 哈哈哈，终于到了这里，虽然我是跳着写过来凑数的，但这都不重要。\n所谓的权限修饰符在一开始接触java就能够看到，也就是所谓的public\n，同时呢与之对应的还有private，protected，默认啥也不写。\nprivate（私房钱） \u0026lt; 默认（家里的钱） \u0026lt; protected（给私生子的钱） \u0026lt; public（所有地方都可以）(作用范围：从小到大)\npublic： 默认：本类以及本包之内可以访问（那么有bro要问了，什么是包，你且往上一节看啊bro） protected： private：私有的，只有当前类可以直接访问 10.static关键词 概述 什么是static？\njava中的成员（变量和方法）等是存在所属性的，可以通过static关键词来识别。\n被static修饰的成员是属于类的放在静态区中 没有static修饰的成员变量和方法则是属于对象的 定义格式和使用 static是静态的意思，可以修饰成员变量或者方法。\n有static修饰的成员变量属于类，可以称为类变量或者静态成员变量。可以直接用类名访问（）\n格式：类名.静态变量\n没有static修饰的成员变量属于每个对象，叫做实例变量。\n（实例成员变量属于每个对象，必须先定义各自类的对象之后才可以访问）\n格式：对象.实例成员变量\n方法同理\n小结 static修饰成员时，该成员称为静态变量或者静态方法。该类的每个对象共享同一个类的静态变量或者静态方法 ","date":"2025-11-25T23:26:00Z","permalink":"http://localhost:1313/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","title":"面向对象"},{"content":"不可变集合 1. 概述 简单来说，就是不想让别人修改集合的内容。\n2. 分类 不可变的list集合 不可变的set集合 不可变的map集合 3. Stream流 ","date":"2025-11-25T16:31:00Z","permalink":"http://localhost:1313/p/stream%E6%B5%81%E5%8A%A8%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","title":"stream流动方法引用"},{"content":"Method 方法 方法就是程序之中最小的执行单元.\n方法必须被定义之后才可以被调用 方法的运行需要手动使用,无法自动运行 方法的定义 定义的格式\n1 2 3 public static void 方法名 ( ) { // 方法体; } 调用的格式:\n1 method(); 带参数的方法 注意\n方法定义时,参数中的数据类型和变量名一个都不能少,缺少任意一个程序就会报错\n方法定义时,多个参数之间使用逗号进行分隔\n有返回值的方法的定义和调用 定义格式\n1 2 3 public static 数据类型 方法名 ( 参数 ) { return 数据 ; } 此处的数据类型和数据要对应哦,不然会报错的😗\n方法的注意事项 方法不能被嵌套定义 调用方法时的注意: void类型的方法,直接调用就行 非void的方法,推荐用变量接收即可 方法重载 就是说,同一个类之中的不同的方法之间的联系,\n前提条件:\n多个方法在用一个类之中\n多个方法具有相同的方法名\n多个方法名的参数数量、类型和顺序的组合,只关心这三个\n如果只有参数的名字不同,就不会构成重载 ​\t(但是返回值的数据类型没有影响)\n重载只针对方法的定义,但是不影响方法的调用\n方法的值传递 ","date":"2025-11-21T14:07:00Z","permalink":"http://localhost:1313/p/%E6%96%B9%E6%B3%95/","title":"方法"},{"content":"无限循环 Random 他是一个类，不关心如何实现，知道怎么用就行\n使用步骤： 1.导包\n1 2 import java.util.Random; 导包的动作必须出现在类定义的上边。 2.创建对象\n1 2 Random r = new Random (); 上面这个格式里面，只有r是变量名，可以变，其他的都不允许变。 3.生成随机数\n1 2 3 int number = r.nextInt(随机数的范围); 上面这个格式里面，只有number是变量名，可以变，其他的都不允许变。 随机数范围的特点：从0开始，不包含指定值。比如：参数为10，生成的范围[0,10) 疑惑:nextInt是个啥?\n","date":"2025-11-21T13:22:00Z","permalink":"http://localhost:1313/p/%E9%AB%98%E7%BA%A7%E5%BE%AA%E7%8E%AF/","title":"高级循环"},{"content":"何为数组 概念 数组就是一种容器，可以用来存储同种数据类型的值。\n注意考虑数组的数据类型和要存储的数据的数据类型是否匹配，如果不一样，再考虑一下隐式转换的问题。\n定义 格式一：\n​\t数据类型[] 数组名\n格式二：\n​\t数据类型 数组名[]\n数组的静态初始化 完整格式：\n​\t数据类型[] 数组名 = new 数据类型[] {元素1， 元素2，元素3}；\n注意点：\n等号前后的数据类型必须保持一致。 数组一旦创建之后，长度不能发生变化。 简化格式：\n​\t数据类型[] 数组名 = { }；\n地址值 使用sout打印数组时，实际出现的时数组的地址值（就是数组在内存中的位置）。\n作用不大，简单了解即可。\n数组元素访问 格式：\n​\t数组名[索引]；\n作用：\n获取数组中对应索引的值 修改索引的值 索引 特点：\n索引一定是从0开始的 连续不间断 逐个+1增长 数组的遍历 数组的长度可以用 数组名.length 来表示\n数组的动态初始化 格式：\n​\t数据类型[] 数组名 = new 数据类型[数组的长度]；\n（与静态初始化对比而言，在中括号中写出了数组的长度，同时没有对数组进行赋值，用以表明知道数量，而不知道具体值，系统会默认根据类型给出默认初始值）\n整数类型：0\n小数类型：0.0\n布尔类型：false\n字符类型：\u0026rsquo;\\u0000'\n引用类型：null\n两种初始化的区别 静态：指定数组的元素\n动态：指定数组的长度\n（只明确数组长度但是不知道具体的数据，使用动态初始化）\n（明确了所有要操作的数据，就要使用静态初始化）\n数组常见问题 ArrayIndexOutOfBoundsException索引越界异常\n最小索引：0\n最大索引：数组的长度-1 or 数组名.length-1\n","date":"2025-11-21T13:07:00Z","permalink":"http://localhost:1313/p/%E6%95%B0%E7%BB%84/","title":"数组"},{"content":"引言 这个叫做java的语言真是有意思，相比于c语言麻烦的结构体指针数组造出来的复杂的各种数据结构，java似乎是直接封装好了在各种叫做集合的东西里，太伟大了！！！\n1.概览 栈和队列 栈结构：先进后出 队列结构：先进先出 数组和链表 数组：查询快、增删慢（数组使用过索引来进行查看的，查询快，但是如果增删则对整个的影响很大） 链表：查询慢、增删快（通过指针实现，增删修改对应的指针就可以，但是查询要挨个运行查看） 哥们，等会儿尝试研究一下为什么这些东西会这样\njava中的集合和数据结构的关系 ArrayList集合\n底层是数组结构 LinkedList集合\n底层是链表结构 TreeSet集合\n底层是个啥 HashSet集合\n底层是哈希表，存取无序，不可以存储重复元素，没有索引 HashMap集合\n底层是哈希表结构的 依赖hashCode方法和equals方法保证键的唯一 如果 TreeMap集合\n底层是红黑树结构\n依赖自然排序或者比较器排序，对键进行排序\n（啥是自然排序和比较器排序）\n如果不懂不懂\n注意他说的lsit和set不可重复\nSet的一个特点是不可以存储重复元素，而且没有索引，不可以使用普通for循环进行遍历\nMap集合的特点\n双列集合，一个键对应一个值 键不可以重复，值可以重复 (瓦达西有点疑惑什么是值)？？？\n2.Collection集合 数组和集合的区别\n相同点\n都是容器（哎嘿，啥是容器？？？）\n不同点\n数组的长度不可变，集合的长度可变 数组可以存储基本数据类型和引用数据类型 集合只可以存储引用数据类型，如果要存基础数据类型。需要存储对应的包装类（xdm，何为基本，何为引用，何为包装类） rt ，这是集合类体系结构，可以分为单列集合Collection和双列集合Map\nCollection集合概述 是单列集合的顶层接口（什么是接口 ：🫣）它表示一组对象，这些对象也称为Collection的元素 创建Collection集合的对象 多态的方式（细嗦多态是什么？） 具体的实现类ArrayList（这是一种常见的父级类new子级类。我也不知道这种算不算正确的说法🤗(╰(°▽°)╯） Collection集合的常见方法 3.what is 泛型 泛型的介绍：\n提供了编译时类型安全检测机制\n泛型定义格式：\n\u0026lt;类型\u0026gt;：指定一个类型的格式，尖括号里面可以任意书写，一般只写一个字母。例如： \u0026lt;类型1，类型2\u0026gt;：指定多种类型的格式，多种类型之间用逗号隔开。 泛型的好处：\n把运行时期的问题提前到了编译期间 避免了强制的类型转换 ​\n","date":"2025-11-20T22:46:00Z","permalink":"http://localhost:1313/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"数据结构"},{"content":"什么是异常 异常\nThrowable可以分为Error和Exception两个种类\nError：严重错误Error，无法通过处理的错误\nException：表示异常，分为编译时期异常checked和运行时期异常\truntime，\n在java中的关键字：throw\n疑惑：异常怎么分类的，抛出的的异常类型是怎么决定的 **没错没错 ** 这就是我的疑惑\nFileNotFoundException\n比如这样的异常类型\n似乎是可以自定义也可以通过使用现成的类型\n什么是抛出异常throw 具体应该如何操作呢？\n创建一个异常对象 提前告知传递给调用者 throw使用在方法之中，用来抛出一个异常对象，并结束当前方法的执行 捕获异常try catch 介绍\n该方法不处理，而是声明抛出，由调用者自己来处理 在方法中使用try-catch的语句块来处理异常 finally代码块 finally中存储的代码块一定会被执行\nfinally不能够单独使用\n异常注意事项 运行时异常被抛出可以不处理，就是不捕获也不声明抛出。 如果父类抛出了多个异常，子类覆盖父类方法时。只能抛出相同的异常或者是他的子集。 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。 当多异常处理时。 概述 为什么需要自定义异常类: ","date":"2025-11-20T19:37:00Z","permalink":"http://localhost:1313/p/%E5%BC%82%E5%B8%B8/","title":"异常"},{"content":"阶段项目 1.主界面搭建 1 2 3 4 5 6 7 8 //1.召唤主界面 JFrame jFrame = new JFrame(); //2.设置主界面的大小 jFrame.setSize(514,595); //3.让主界面显示出来 jFrame.setVisible(true); 2.主界面的其他设置 jFrame.setVisible(true);必须写在最后一行\n3.利用继承简化代码 ​\t通过继承来将界面分为注册界面，登录界面和主界面。\n4.菜单制作 ​\t在菜单中有：JMenuBar、JMenu、JMenuItem三个角色。\nJMenuBar：如上图中红色边框 JMenu：如上图蓝色边框 JMenuItem：如上图绿色字体处 其中JMenuBar是整体，一个界面中一般只有一个JMenuBar。\n而JMenu是菜单中的选项，可以有多个。\nJMenuItem是选项下面的条目，也可以有多个。\n书写步骤 1，创建JMenuBar对象\n2，创建JMenu对象\n3，创建JMenuItem对象\n4，把JMenuItem添加到JMenu中\n5，把JMenu添加到JMenuBar中\n6，把整个JMenuBar设置到整个界面中\n5.添加图片 使用到的java类有：\nImageIcon：描述图片的类。可以关联计算机中任意位置的图片 JLabel：用来管理图片，文字的类。用来设置位置，宽高。 步骤：\n​\t1，取消整个界面的默认居中布局\n​\t2，创建ImageIcon对象，并制定图片位置。\n​\t3，创建JLabel对象，并把ImageIcon对象放到小括号中。\n​\t4，利用JLabel对象设置大小，宽高。\n​\t5，将JLabel对象添加到整个界面当中。\n6.打乱图片的位置 重点如何通过random类来进行随机打乱\n7.事件 事件是可以被组件识别的操作（那么，古尔丹，什么是组件呢？）\n常见的三个核心要素\n事件源 事件 绑定监听 常见的三种事件监听\n键盘监听 KeyListener 鼠标监听 MouseListener 动作监听 ActionListener 动作监听\n鼠标左键点击 空格 事件的三种实现方式\n定义实现类实现接口 匿名内部类 本类实现接口 （heyhey，再次提问上面三个名词都是什么东西呢？）\n","date":"2025-11-20T19:31:00Z","permalink":"http://localhost:1313/p/%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE/","title":"阶段项目"},{"content":" 1. IO流概述 1.1 IO流介绍 ​\t生活中，当我们在电脑上编辑文本文件的时候，如果忘记了使用ctrl+s的话，文本可能就会白白编辑。如果我们把u盘插在电脑上，就可以把视频等拷贝到电脑上。\n​\t而我们把这种数据之间的传输，可以看做是数据的流动，按照流动的方向，以内存为基准，分为input和output两种，就是说流向内存的是输入流，流出内存的输出流（这里要明确内存指的是哪个?）\n​\tJava中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。\n1.2 IO的分类 如上，根据数据的流向可以分为：\n输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 都属于抽象类，无法创建他们的对象\n而根据传输数据的类型可以分为：\n字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 注意字节流可以操纵所有类型的文件，字符流只可以操纵纯文本文件\n1.3 IO的流向说明图解 1.4 顶级父类们 输入流 输出流 字节流 字节输入流 InputStream 字节输出流 OutputStream 字符流 字符输入流 Reader 字符输出流 Writer 两两分类交叉就生成了四个东西，如此神奇（bushi）\n2.字节流OutPutStream 2.1 一切皆为字节（阿门） 一切的文本数据（文本、视频、图片等等）在存储时，都是以二进制数字的方式存储，都是一个一个的字节，那么传输时也是如此，所以字节流可以传输任意的文件数据，我们必须明确，在操作流的时候，无论使用什么样的流对象（啥是流对象？），底层传输的始终都是二进制数据。\n2.2 字节输出流【OutPutStream】 2.3 FileOutputStream类 ​\tFileOutputStream可以把程序中的数据写入文本之中，同时默认使用ASCII编码进行输出，可以使用强类型转换来直接输出，如果想要实现同一行输出的效果，可以使用print而不是println。\n​\t最后要注意用fos.close来进行资源的释放，避免占用系统的进程。\n​\t创建字节输出流对象的时候：\n如果参数是字符串表示的路径或者是File对象都可以\n如果文件不存在则会自动创建一个新的文件，但是要保证父级路径存在\n四、字节输出流写出数据的三种方式\n1 2 3 void write(int b) void write(byte[] b) void write(byte[] b, int off, int len) 五、换行和续写\n​\t换行：采用\\r\\n，延续老式打字机的先回车再换行的传统\n​\t续写：如果想要打开续写，则再创建对象时候在第二个参数处写true，如果不写的话则会默认显示false\n2.4 字节输入流【InputStream】 2.5 FileInputStream类 3. 字符流 4.IO异常的处理 5.综合小练 6.File类是什么 概述 java.io.File类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。\n构造方法 我来考考你：什么是构造方法来着，以及什么时候会用到默认的构造方法呢？\nFile(String pathname) File(String parent, String child) File(File parent，String child) 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 文件路径名 String pathname = \u0026#34;D:\\\\aaa.txt\u0026#34;; File file1 = new File(pathname); // 文件路径名 String pathname2 = \u0026#34;D:\\\\aaa\\\\bbb.txt\u0026#34;; File file2 = new File(pathname2); // 通过父路径和子路径字符串 String parent = \u0026#34;d:\\\\aaa\u0026#34;; String child = \u0026#34;bbb.txt\u0026#34;; File file3 = new File(parent, child); // 通过父级File对象和子路径字符串 File parentDir = new File(\u0026#34;d:\\\\aaa\u0026#34;); String child = \u0026#34;bbb.txt\u0026#34;; File file4 = new File(parentDir, child); 一个File对象代表硬盘中实际存在的一个文件或者目录 无论该路径之下是否存在其他文件或者目录，都不影响File对象的创建 常用方法 获取功能的方法\n判断功能的方法\n创建删除功能的方法\n目录的遍历 public String[] list(): public File[] listFiles() 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则会返回null，无法进行遍历。\n","date":"2025-11-20T18:42:00Z","permalink":"http://localhost:1313/p/io%E6%B5%81/","title":"IO流（）"},{"content":" 1. IO流概述 1.1 IO流介绍 ​\t生活中，当我们在电脑上编辑文本文件的时候，如果忘记了使用ctrl+s的话，文本可能就会白白编辑。如果我们把u盘插在电脑上，就可以把视频等拷贝到电脑上。\n​\t而我们把这种数据之间的传输，可以看做是数据的流动，按照流动的方向，以内存为基准，分为input和output两种，就是说流向内存的是输入流，流出内存的输出流（这里要明确内存指的是哪个?）\n​\tJava中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。\n1.2 IO的分类 如上，根据数据的流向可以分为：\n输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 都属于抽象类，无法创建他们的对象\n而根据传输数据的类型可以分为：\n字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 注意字节流可以操纵所有类型的文件，字符流只可以操纵纯文本文件\n1.3 IO的流向说明图解 1.4 顶级父类们 输入流 输出流 字节流 字节输入流 InputStream 字节输出流 OutputStream 字符流 字符输入流 Reader 字符输出流 Writer 两两分类交叉就生成了四个东西，如此神奇（bushi）\n2.字节流OutPutStream 2.1 一切皆为字节（阿门） 一切的文本数据（文本、视频、图片等等）在存储时，都是以二进制数字的方式存储，都是一个一个的字节，那么传输时也是如此，所以字节流可以传输任意的文件数据，我们必须明确，在操作流的时候，无论使用什么样的流对象（啥是流对象？），底层传输的始终都是二进制数据。\n2.2 字节输出流【OutPutStream】 2.3 FileOutputStream类 ​\tFileOutputStream可以把程序中的数据写入文本之中，同时默认使用ASCII编码进行输出，可以使用强类型转换来直接输出，如果想要实现同一行输出的效果，可以使用print而不是println。\n​\t最后要注意用fos.close来进行资源的释放，避免占用系统的进程。\n​\t创建字节输出流对象的时候：\n如果参数是字符串表示的路径或者是File对象都可以\n如果文件不存在则会自动创建一个新的文件，但是要保证父级路径存在\n四、字节输出流写出数据的三种方式\n1 2 3 void write(int b) void write(byte[] b) void write(byte[] b, int off, int len) 五、换行和续写\n​\t换行：采用\\r\\n，延续老式打字机的先回车再换行的传统\n​\t续写：如果想要打开续写，则再创建对象时候在第二个参数处写true，如果不写的话则会默认显示false\n2.4 字节输入流【InputStream】 2.5 FileInputStream类 3. 字符流 4.IO异常的处理 5.综合小练 6.File类是什么 概述 java.io.File类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。\n构造方法 我来考考你：什么是构造方法来着，以及什么时候会用到默认的构造方法呢？\nFile(String pathname) File(String parent, String child) File(File parent，String child) 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 文件路径名 String pathname = \u0026#34;D:\\\\aaa.txt\u0026#34;; File file1 = new File(pathname); // 文件路径名 String pathname2 = \u0026#34;D:\\\\aaa\\\\bbb.txt\u0026#34;; File file2 = new File(pathname2); // 通过父路径和子路径字符串 String parent = \u0026#34;d:\\\\aaa\u0026#34;; String child = \u0026#34;bbb.txt\u0026#34;; File file3 = new File(parent, child); // 通过父级File对象和子路径字符串 File parentDir = new File(\u0026#34;d:\\\\aaa\u0026#34;); String child = \u0026#34;bbb.txt\u0026#34;; File file4 = new File(parentDir, child); 一个File对象代表硬盘中实际存在的一个文件或者目录 无论该路径之下是否存在其他文件或者目录，都不影响File对象的创建 常用方法 获取功能的方法\n判断功能的方法\n创建删除功能的方法\n目录的遍历 public String[] list(): public File[] listFiles() 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则会返回null，无法进行遍历。\n","date":"2025-11-20T18:42:00Z","permalink":"http://localhost:1313/p/io%E6%B5%81/","title":"IO流（）"},{"content":"Object类 概述 可以说Object类是所有类的父类，其他所有类都直接或者间接地继承于Object类。也就是说，该类所具备的所有方法，其他所有类都继承了。\n常见方法 toString\t返回该对象的字符串表示形式，可以用字符串的数据类型 接收 equals clone toString 在某一类中空白处点击alt+insert可以快速重写其toString的方法（需要实现定义好属性）\n注意事项\n通过输出语句输出一个对象时，默认调用的就是toString（）方法 可以通过重写toString方法类输出对应的成员变量信息（快捷键：atl + insert ， 空白处 右键 -\u0026gt; Generate -\u0026gt; 选择toString） ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""},{"content":"Runtime 主要类 getRuntime 当前系统的运行环境对象 exit 停止虚拟机 availableProcessors 获得cpu的线程数 maxMemory JVM能从系统中获取内存的大小 totalMemory JVM已经从系统中获取的总内存大小 freeMemory JVM的剩余内存大小 exec 运行cmd命令 概述 针对虚拟机执行的各种命令。\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""},{"content":"什么是API 就是Application Programming Interface,应用程序编程接口\n而java之中API就是JDK里面提供的各种的java类,封装了各种各样的功能,十分便利.\nAPI帮助文档怎么用 String类(字符串) ​\tjava程序里面所有带有双括号的字符串都属于String类的对象(类和对象应用十分的广泛)\n特点 字符串一旦创建,就无法再次改变他们的值 虽然String的值不可变,但是他们可以被共享(啥子是共享?) 字符串效果上相当于字符数组(char[]),但是字符串的底层原理时字节数组(byte[]) String的构造方法 常用的四个\n方法名 说明 public String() 创建一个空白字符串对象，不含有任何内容 public String(char[] chs) 根据字符数组的内容，来创建字符串对象 public String(byte[] bys) 根据字节数组的内容，来创建字符串对象 String s = “abc”; 直接赋值的方式创建字符串对象，内容就是abc 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class StringDemo01 { public static void main(String[] args) { //public String()：创建一个空白字符串对象，不含有任何内容 String s1 = new String(); System.out.println(\u0026#34;s1:\u0026#34; + s1); //public String(char[] chs)：根据字符数组的内容，来创建字符串对象 char[] chs = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}; String s2 = new String(chs); System.out.println(\u0026#34;s2:\u0026#34; + s2); //public String(byte[] bys)：根据字节数组的内容，来创建字符串对象 byte[] bys = {97, 98, 99}; String s3 = new String(bys); System.out.println(\u0026#34;s3:\u0026#34; + s3); //String s = “abc”;\t直接赋值的方式创建字符串对象，内容就是abc String s4 = \u0026#34;abc\u0026#34;; System.out.println(\u0026#34;s4:\u0026#34; + s4); } } 括号里面的参数填进去的实参要真实存在哦\n创建字符串对象两种方式的区别 StringBuilder StringJoiner 字符串的扩展知识 ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""},{"content":"7.多态 7.1多态的形式 ☆: .｡. o(≧▽≦)o .｡.:☆多态来啦，是他是他就是他，面向对象第三特性小多态，一般出现在继承或者实现关系之中\n（疑惑：啥是实现关系）\n多态的体现格式：\n1 2 3 4 父类类型 变量名 = new 子类/实现类构造器; 变量名.方法名(); Human h1 = new Student; 左边写父类，右边写子类，我叫多态你记住！！\n多态的前提：有继承关系，子类对象是可以赋值给父类类型的变量。\n（为什么有这个前提呢？）\n7.2多态的使用场景 ​\t通过多态可以减少代码量，比如如果针对一个父类的多个子类要进行一样的传参，如果没有多态，要重复书写不同子类参数的相同方法，但是有了多态既可以把只写一个，把参数改为父类就可以了。\n​\t有了多态之后，方法的形参就可以定义为共同的父类。\n注意：\n7.3 多态的定义和前提 8.final关键字 表示最终，不可被改变（用于不希望被别人改变的东西）\n修饰对象：\n方法：最终方法，不可以被重写 类：最终类，不可以被继承 变量：常量，只能被赋值一次 修饰基本数据类型：记录的值不可以发生改变 修饰引用数据类型：记录的地址值不能发生改变，内部的属性值还是可以改变的 （基础数据类型是存储数据本身的，而引用数据类型是指向堆内存中对象的引用（地址））\n举例\n基础：int 引用：接口，数组，类 ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""},{"content":"继承 什么是继承?\n如果多个类中有多个相同的属性和行为时,就可以使用继承来减少冗杂的代码量,只需要将所有的重复的属性和行为抽离到单独的一个类之中。\n其中单独被继承的那个类叫做父类，（超类，基类）\n而多个继承的类叫做子类。\n1. 承的好处： 让子类可以直接访问父类之中非私有的属性和行为（但是私有的就不可以访问哦，这也是继承与封装的联系）\n2. 继承的格式 通过extends关键字\n1 2 3 4 5 6 7 class 父类 { ... } class 子类 extends 父类 { ... } 注意注意敲黑板咯,一个儿子只能有一个亲爹，就是直系父亲，同理可得一个子类只能继承一个直接父类\n这是案例展示！😋\n3. 子类不能继承于父类的部分 构造方法 可以继承父类的私有成员，但是无法直接访问而已 4. 继承后的特点\u0026ndash;成员变量 特殊情况：\n成员变量重名\n子类优先访问自己对象中的成员变量 如果想要访问父类成员变量，可以使用super关键字 super访问父类成员变量 ​\t可以使用super关键字，来修饰父类成员变量，类似于之前的this关键字。\n注意：super指的是父类对象的引用，this指的是当前对象的引用。\n使用格式：\n1 super.父类成员变量名 5. 继承后的特点\u0026ndash;成员方法 同上,如果成员方法同名,(●\u0026rsquo;◡\u0026rsquo;●)\n优先调用子类中的方法 没有什么super用来实现父类的方法 6. 方法重写 概念 子类出现与父类完全相同（返回值类型，方法名字和参数列表都相同）时，会出现覆盖效果，也成为重写或者复写。\n注意：声明不变，重新实现\n@Override重写注解 @OVerride：注解，重写注解校验！ 使用场景：\n当子类继承了父类的方法，但是父类的方法不足以满足子类的要求，所有子类可以去进行方法重写来满足自己的需求。\n注意事项：\n方法重写发生在父子类之间 子类方法覆盖父类方法，要保证子类权限大于等父类 子类方法覆盖父类方法，返回值类型，函数名字和参数列表都要一模一样 7. 继承后的特点\u0026mdash;构造方法 引入 ​\n8. super（）和this（） ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/p/","title":""}]